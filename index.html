<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <title>Texto a Voz con Web Speech API</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="config.js"></script>
    <style>
      /* Animaciones y detalles no cubiertos por Tailwind */
      @media (prefers-color-scheme: dark) {
        body {
          background: linear-gradient(135deg, #1a2320 60%, #121814 100%) !important;
          background-repeat: no-repeat;
          background-attachment: fixed;
        }
      }
      #micBtn.recording {
        animation: pulse 1.2s infinite;
      }
      #micBtn::after {
        content: '';
        display: block;
        position: absolute;
        left: 50%;
        top: 50%;
        width: 120px;
        height: 120px;
        background: radial-gradient(circle, #b7e4c722 0%, transparent 80%);
        border-radius: 50%;
        transform: translate(-50%, -50%);
        z-index: 0;
        pointer-events: none;
        opacity: 0.5;
        transition: opacity 0.3s;
      }
      #micBtn.recording::after {
        animation: mic-wave 1.2s infinite;
        opacity: 0.7;
      }
      @keyframes mic-wave {
        0% { opacity: 0.7; transform: translate(-50%, -50%) scale(1); }
        70% { opacity: 0.10; transform: translate(-50%, -50%) scale(1.18); }
        100% { opacity: 0.0; transform: translate(-50%, -50%) scale(1.3); }
      }
      @keyframes pulse {
        0% { box-shadow: 0 0 0 0 #b7e4c733; }
        70% { box-shadow: 0 0 0 12px #b7e4c700; }
        100% { box-shadow: 0 0 0 0 #b7e4c700; }
      }
      #chatContainer {
        position: relative;
        z-index: 1;
        min-height: 320px;
        background: transparent;
        overflow-y: auto;
        padding-bottom: 180px; /* Aumentado para dar espacio al último mensaje */
        scroll-behavior: smooth; /* Desplazamiento suave */
      }
      .placeholder-vallabus {
        position: absolute;
        top: 15%;
        left: 15%;
        transform: translate(-15%, -15%);
        text-align: left;
        opacity: 0.80;
        z-index: 2;
      }
      .placeholder-vallabus p {
        line-height: 1.6;
      }
      /* Micrófono superpuesto y grande */
      .mic-btn-container {
        position: fixed;
        left: 50%;
        bottom: 96px;
        transform: translate(-50%, 0);
        z-index: 20;
        display: flex;
        flex-direction: column;
        align-items: center;
        pointer-events: none;
      }
      #micBtn {
        width: 110px !important;
        height: 110px !important;
        font-size: 3.2rem !important;
        margin: 0;
        pointer-events: auto;
      }
      #micBtn.recording {
      }
      @media (max-width: 500px) {
        #micBtn { width: 80px !important; height: 80px !important; font-size: 2.2rem !important; }
        .mic-btn-container { bottom: 72px; }
      }
      .bottom-bar-vallabus {
        padding-top: 60px !important;
      }
      /* Barra inferior fija */
      .fixed-bottom-bar {
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100vw;
        background: #fff;
        border-top: 1.5px solid #d1f2e0;
        z-index: 10;
        min-height: 88px; /* Aumentado para dar más espacio */
        display: flex;
        justify-content: center;
        align-items: center;
        background: #fff;
        padding: 10px 0;
        padding-bottom: calc(10px + env(safe-area-inset-bottom, 0)); /* Soporte para dispositivos con muesca */
        box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.05);
        position: relative; /* Añadido para que el posicionamiento absoluto del loader sea relativo a este contenedor */
      }
      #info {
        margin: 0 12px;
        padding: 8px 16px;
        transition: all 0.3s ease;
      }
      
      #stopBtn {
        margin: 0 12px;
        white-space: nowrap;
      }
    </style>
  </head>
  <body class="bg-[#5f7262] dark:bg-[#1a2320] text-[#1e4636] dark:text-[#eaf7ef] min-h-screen flex flex-col justify-between font-sans" style="background: linear-gradient(135deg, #5f7262 60%, #34453a 100%); background-repeat: no-repeat; background-attachment: fixed;">
    <!-- Encabezado fijo -->
    <header class="fixed top-0 left-0 right-0 bg-[#434f48] dark:bg-[#212d26] text-white py-3 z-40 shadow-md cursor-pointer" onclick="document.getElementById('chatContainer').scrollTo({top: 0, behavior: 'smooth'})">
      <h1 class="text-xl font-bold text-center">Asistente VallaBus</h1>
    </header>
    
    <div class="relative flex-1 w-full max-w-md mx-auto px-2 overflow-y-auto space-y-2 pt-16" id="chatContainer">
      <div id="placeholderVallaBus" class="placeholder-vallabus text-white dark:text-white text-base font-bold">
        <p class="text-white dark:text-white text-4xl">¡Hola! <br> Pregúntame sobre paradas, horarios o cómo llegar a un destino</p>
      </div>
      <!-- Los mensajes se irán agregando aquí dinámicamente -->
    </div>
    <!-- Micrófono superpuesto -->
    <div class="mic-btn-container w-full max-w-md flex justify-center pointer-events-none fixed left-1/2 bottom-14 translate-x-[-50%] z-30">
      <button id="micBtn" title="Hablar o parar" class="relative flex items-center justify-center rounded-full shadow-md transition-all outline-none focus:ring-2 focus:ring-[#7db698] pointer-events-auto
        bg-[#434f48] text-white border-4 border-[#698374]
        dark:bg-[#3b5648] dark:text-[#b7e4c7] dark:border-[#355347]">
        <span id="micIcon"><i class="fa-solid fa-microphone"></i></span>
      </button>
    </div>
    <!-- Barra inferior fija con info -->
    <div class="fixed-bottom-bar bg-white border-t-[1.5px] border-[#d1f2e0] dark:bg-[#1c2623] dark:border-t-[#355347] dark:shadow-[0_-2px_24px_#0008] min-h-[88px] flex items-center justify-center">
  <div id="info" class="text-[#4e8c6c] dark:text-[#b7e4c7] text-base text-center font-medium">Pulsa para hablar</div>
  <div class="loader absolute left-0 right-0 flex flex-col items-center justify-center hidden" id="loader">
    <span class="text-[#4e8c6c] dark:text-[#b7e4c7] text-base font-semibold">Pensando...</span>
  </div>
  <button id="stopBtn" class="rounded-lg bg-[#b7e4c7] dark:bg-[#23382b] text-[#228b54] dark:text-[#b7e4c7] font-semibold py-2 px-4 shadow transition hidden">Detener audio</button>
</div>
    <script>
    document.addEventListener('DOMContentLoaded', function() {
      const micBtn = document.getElementById('micBtn');
      const micIcon = document.getElementById('micIcon');
      const info = document.getElementById('info');
      let voices = [];
      let recognizing = false;
      let recognition;
      let respuestaPendiente = null;
      let recognitionEnded = true;
      let utteranceActual = null; // Para evitar que el recolector de basura corte la voz
      // Generar o recuperar un id único de usuario
      function getUserId() {
        let id = localStorage.getItem('usuario_id');
        if (!id) {
          if (window.crypto && window.crypto.randomUUID) {
            id = crypto.randomUUID();
          } else {
            // Fallback simple
            id = 'u-' + Math.random().toString(36).slice(2) + Date.now();
          }
          localStorage.setItem('usuario_id', id);
        }
        return id;
      }
      const usuarioId = getUserId();
      // Cargar voces
      function loadVoices() {
        voices = window.speechSynthesis.getVoices();
      }
      window.speechSynthesis.onvoiceschanged = loadVoices;
      loadVoices();
      // Reconocimiento de voz
      function startRecognition() {
        if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
          info.textContent = 'Tu navegador no soporta reconocimiento de voz.';
          return;
        }
        recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
        recognition.lang = 'es-ES';
        recognition.interimResults = false;
        recognition.maxAlternatives = 1;
        recognition.onstart = () => {
          recognizing = true;
          recognitionEnded = false;
          micBtn.classList.add('recording');
          info.textContent = 'Escuchando... Pulsa de nuevo para parar.';
        };
        recognition.onresult = (event) => {
          const transcript = event.results[0][0].transcript;
          info.textContent = '';
          document.getElementById('loader').style.display = 'flex';
          // Mostrar pregunta detectada
          addMessage(transcript, 'user');
          recognition.stop(); // Detener reconocimiento inmediatamente
          // Enviar al webhook
          // Codificar credenciales en base64 para Basic Auth
          const credentials = btoa(`${WEBHOOK_USER}:${WEBHOOK_PASS}`);
          fetch('https://tasks.nukeador.com/webhook/2d4dfc03-6c23-43ce-a419-c717c33799b5', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Basic ${credentials}`
            },
            body: JSON.stringify({ texto: transcript, usuario_id: usuarioId })
          })
            .then(res => res.json())
            .then(data => {
              document.getElementById('loader').style.display = 'none';
              let respuesta = data.output || 'Lo siento, en estos momentos no puedo ayudarte, prueba de nuevo en un rato.';
              // Reemplazar todas las URLs por un marcador especial para la voz
              const urlRegex = /(https?:\/\/[^\s]+)/g;
              // Eliminar emojis para la voz (sin eliminar números)
              // Regex seguro para solo emojis (sin error de rango)
              const emojiRegex = /([\u203C-\u3299\uD83C-\uDBFF][\uDC00-\uDFFF]?)/g;
              let respuestaParaVoz = respuesta.replace(emojiRegex, '').replace(urlRegex, '___ENLACE___');
              // Para la vista, mostrar enlaces clicables con color verde acorde al theme
              const respuestaConEnlaces = respuesta.replace(urlRegex, url => {
                try {
                  const urlObj = new URL(url);
                  return `<a href="${url}" target="_blank" rel="noopener" class="text-[#228b54] dark:text-[#7be495] underline">${urlObj.hostname}</a>`;
                } catch {
                  return url;
                }
              }).replace(/\n/g, '<br>');
              addMessage(respuestaConEnlaces, 'bot');
              respuestaPendiente = respuestaParaVoz;
              if (recognitionEnded && respuestaPendiente) {
                speakLongText(respuestaPendiente);
                respuestaPendiente = null;
              }
            })
            .catch(err => {
              document.getElementById('loader').style.display = 'none';
              info.textContent = 'Error al procesar la consulta.';
            });
        };
        recognition.onerror = (event) => {
          info.textContent = 'Error: ' + event.error;
          recognizing = false;
          micBtn.classList.remove('recording');
        };
        recognition.onend = () => {
          recognizing = false;
          recognitionEnded = true;
          micBtn.classList.remove('recording');
          if (respuestaPendiente) {
            speakLongText(respuestaPendiente);
            respuestaPendiente = null;
          }
        };
        recognition.start();
      }
      function splitTextForSpeech(text) {
        // Divide por frases y luego por fragmentos de máximo 200 caracteres
        let rawFrases = text.split(/(?<=[.!?;:,\n])\s+/g);
        let frases = [];
        rawFrases.forEach(f => {
          let frase = f.trim();
          while (frase.length > 200) {
            let corte = frase.lastIndexOf(' ', 200);
            if (corte === -1) corte = 200;
            frases.push(frase.slice(0, corte));
            frase = frase.slice(corte).trim();
          }
          if (frase.length > 0) frases.push(frase);
        });
        return frases;
      }

      let speakLongTextCancelado = false; // GLOBAL

function speakLongText(text) {
  const frases = splitTextForSpeech(text);
  let idx = 0;
  speakLongTextCancelado = false;
  // Actualizar el estado a "hablando"
  setSpeakingState(true);
  
  function speakNext() {
    if (speakLongTextCancelado || idx >= frases.length) {
            // Si se terminó de hablar o se canceló
            setSpeakingState(false);
            return;
          }
          
          let frase = frases[idx].trim();
          // Si la frase contiene el marcador especial, decir 'Consulta el enlace.'
          if (frase.includes('___ENLACE___')) {
            frase = 'Consulta el enlace.';
          }
          
          utteranceActual = new SpeechSynthesisUtterance(frase);
          utteranceActual.lang = 'es-ES';
          const vocesEs = voices.filter(voice => voice.lang.startsWith('es'));
          if (vocesEs.length > 0) utteranceActual.voice = vocesEs[0];
          utteranceActual.volume = 1;
          utteranceActual.rate = 1;
          utteranceActual.pitch = 1;
          
          utteranceActual.onstart = () => {
            setSpeakingState(true);
          };
          
          utteranceActual.onend = () => {
            utteranceActual = null;
            idx++;
            speakNext();
          };
          
          utteranceActual.onerror = (e) => {
            utteranceActual = null;
            console.log('Error en síntesis:', e.error);
            idx++;
            speakNext();
          };
          
          window.speechSynthesis.speak(utteranceActual);
        }
        speakNext();
      }
      micBtn.addEventListener('click', () => {
        window.speechSynthesis.cancel(); // Detener cualquier voz en curso
        if (recognizing) {
          recognition.stop();
          recognizing = false;
          micBtn.classList.remove('recording');
          info.textContent = 'Procesando...';
        } else {
          startRecognition();
        }
      });

      // --- FIN: Lógica de tema eliminada ---

      // Reemplazar la lógica de mostrar mensajes en userBubble/chatBubble por agregar elementos al chatContainer
      function addMessage(text, sender) {
        const chatContainer = document.getElementById('chatContainer');
        const div = document.createElement('div');
        div.className = sender === 'user'
          ? 'chat-bubble user-bubble bg-[#c0d6c5] dark:bg-[#23382b] text-[#1e4636] dark:text-[#eaf7ef] border border-[#d1f2e0] dark:border-[#3a4d44] rounded-2xl px-4 py-2 text-base w-fit self-end shadow-sm max-w-[90%] mb-3 mr-2'
          : 'chat-bubble bg-[#f8fef9] dark:bg-[#2e4d3a] text-[#185d39] dark:text-[#b7e4c7] border border-[#d1f2e0] dark:border-[#3a4d44] rounded-2xl px-4 py-2 text-xl w-fit shadow-sm max-w-[90%] mb-3 ml-2';
        div.innerHTML = text;
        chatContainer.appendChild(div);
        
        // Asegurar que el scroll muestre el último mensaje
        requestAnimationFrame(() => {
          chatContainer.scrollTo({
            top: chatContainer.scrollHeight,
            behavior: 'smooth'
          });
        });
        
        // Actualizar el placeholder (si existe)
        updatePlaceholder();
        updatePlaceholder();
      }

      // Mostrar/ocultar placeholder según si hay mensajes
      function updatePlaceholder() {
        const chatContainer = document.getElementById('chatContainer');
        const placeholder = document.getElementById('placeholderVallaBus');
        // Si hay algún mensaje, ocultar placeholder
        const bubbles = chatContainer.querySelectorAll('.chat-bubble');
        if (bubbles.length > 0) {
          placeholder.style.display = 'none';
        } else {
          placeholder.style.display = 'block';
        }
      }
      // Función para actualizar la interfaz cuando el asistente está hablando
      function setSpeakingState(isSpeaking) {
        const info = document.getElementById('info');
        const loader = document.getElementById('loader');
        const stopBtn = document.getElementById('stopBtn');
        
        if (isSpeaking) {
          info.classList.add('hidden');
          loader.classList.add('hidden');
          stopBtn.classList.remove('hidden');
        } else {
          info.textContent = 'Pulsa para hablar';
          info.classList.remove('hidden');
          loader.classList.add('hidden');
          stopBtn.classList.add('hidden');
        }
      }

      // Modificar addMessage para actualizar el placeholder
      const originalAddMessage = addMessage;
      window.addMessage = function(text, sender) {
        originalAddMessage(text, sender);
        updatePlaceholder();
      };
      
      // Llamar al cargar
      updatePlaceholder();
      
      // Detener el audio cuando se presiona el botón de detener
      document.getElementById('stopBtn').addEventListener('click', () => {
        speakLongTextCancelado = true;
        window.speechSynthesis.cancel();
        setSpeakingState(false);
      });
    });
  </script>
</body>
</html>
